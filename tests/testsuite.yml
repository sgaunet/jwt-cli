name: Exec testsuite
vars:
  EMAIL: test@test.com

testcases:

- name: init
  steps:
  - type: exec
    script: |
      rm *.key *.pub *.pem || true

- name: create RS256 RS384 RS512 keys
  steps:
  - type: exec
    script: |
      # RS256
      ssh-keygen -t rsa -b 4096 -E SHA256 -m PEM -P "" -f RS256-private.pem
      openssl rsa -in RS256-private.pem -pubout -outform PEM -out RS256-public.pem

      # RS384
      ssh-keygen -t rsa -b 4096 -E SHA384 -m PEM -P "" -f RS384-private.pem
      openssl rsa -in RS384-private.pem -pubout -outform PEM -out RS384-public.pem

      # RS512
      ssh-keygen -t rsa -b 4096 -E SHA512 -m PEM -P "" -f RS512-private.pem
      openssl rsa -in RS512-private.pem -pubout -outform PEM -out RS512-public.pem

- name: create ES256 ES384 ES512 keys
  steps:
  - type: exec
    script: |
      # ES256
      openssl ecparam -genkey -name prime256v1  -noout -out ES256-private.pem
      openssl ec -in ES256-private.pem -pubout -out ES256-public.pem

      # ES384
      openssl ecparam -name secp384r1 -genkey -noout -out ES384-private.pem
      openssl ec -in ES384-private.pem -pubout -out ES384-public.pem

      # ES512
      openssl ecparam -genkey -name secp521r1 -noout -out ES512-private.pem
      openssl ec -in ES512-private.pem -pubout -out ES512-public.pem 


- name: encode_JWT_with_RS256
  steps:
  - type: exec
    script: |
      cd ..
      go run . encode rs256 --pk tests/RS256-private.pem --p '{ "email": "{{.EMAIL}}" }' 
    assertions:
    - result.code ShouldEqual 0
    vars:
      token:
        from: result.systemout
        # regex: foo with a ([a-z]+) here

- name: decode JWT with RS256 with private key
  steps:
  - type: exec
    script: |
      cd ..
      go run . decode rs256 --pk tests/RS256-private.pem --t '{{.encode_JWT_with_RS256.token}}'
    # info: go run . decode rs256 --pk tests/RS256-private.pem --t '{{.encode_JWT_with_RS256.token}}'
    assertions:
    - result.code ShouldEqual 0

- name: decode JWT with RS256 with public key
  steps:
  - type: exec
    script: |
      cd ..
      go run . decode rs256 --pubk tests/RS256-public.pem --t '{{.encode_JWT_with_RS256.token}}'
    # info: go run . decode rs256 --pubk tests/RS256-public.pem --t '{{.encode_JWT_with_RS256.token}}'
    assertions:
    - result.code ShouldEqual 0

- name: encode_JWT_with_RS384
  steps:
  - type: exec
    script: |
      cd ..
      go run . encode rs384 --pk tests/RS384-private.pem --p '{ "email": "{{.EMAIL}}" }' 
    assertions:
    - result.code ShouldEqual 0
    vars:
      token:
        from: result.systemout
        # regex: foo with a ([a-z]+) here

- name: decode JWT with RS384 with private key
  steps:
  - type: exec
    script: |
      cd ..
      go run . decode rs384 --pk tests/RS384-private.pem --t '{{.encode_JWT_with_RS384.token}}'
    # info: go run . decode rs384 --pk tests/RS384-private.pem --t '{{.encode_JWT_with_RS384.token}}'
    assertions:
    - result.code ShouldEqual 0

- name: decode JWT with RS384 with public key
  steps:
  - type: exec
    script: |
      cd ..
      go run . decode rs384 --pubk tests/RS384-public.pem --t '{{.encode_JWT_with_RS384.token}}'
    # info: go run . decode rs384 --pubk tests/RS384-public.pem --t '{{.encode_JWT_with_RS384.token}}'
    assertions:
    - result.code ShouldEqual 0


- name: encode_JWT_with_RS512
  steps:
  - type: exec
    script: |
      cd ..
      go run . encode rs512 --pk tests/RS512-private.pem --p '{ "email": "{{.EMAIL}}" }' 
    assertions:
    - result.code ShouldEqual 0
    vars:
      token:
        from: result.systemout
        # regex: foo with a ([a-z]+) here

- name: decode JWT with RS512 with private key
  steps:
  - type: exec
    script: |
      cd ..
      go run . decode rs512 --pk tests/RS512-private.pem --t '{{.encode_JWT_with_RS512.token}}'
    # info: go run . decode rs512 --pk tests/RS512-private.pem --t '{{.encode_JWT_with_RS512.token}}'
    assertions:
    - result.code ShouldEqual 0

- name: decode JWT with RS384 with public key
  steps:
  - type: exec
    script: |
      cd ..
      go run . decode rs384 --pubk tests/RS384-public.pem --t '{{.encode_JWT_with_RS384.token}}'
    # info: go run . decode rs384 --pubk tests/RS384-public.pem --t '{{.encode_JWT_with_RS384.token}}'
    assertions:
    - result.code ShouldEqual 0

- name: encode_JWT_with_ES256
  steps:
  - type: exec
    script: |
      cd ..
      go run . encode es256 --pk tests/ES256-private.pem --p '{ "email": "{{.EMAIL}}" }' 
    assertions:
    - result.code ShouldEqual 0
    vars:
      token:
        from: result.systemout
        # regex: foo with a ([a-z]+) here

- name: decode JWT with ES256 with private key
  steps:
  - type: exec
    script: |
      cd ..
      go run . decode es256 --pk tests/ES256-private.pem --t '{{.encode_JWT_with_ES256.token}}'
    # info: go run . decode es256 --pk tests/ES256-private.pem --t '{{.encode_JWT_with_ES256.token}}'
    assertions:
    - result.code ShouldEqual 0

- name: decode JWT with ES256 with public key
  steps:
  - type: exec
    script: |
      cd ..
      go run . decode es256 --pubk tests/ES256-public.pem --t '{{.encode_JWT_with_ES256.token}}'
    # info: go run . decode es256 --pubk tests/ES256-public.pem --t '{{.encode_JWT_with_ES256.token}}'
    assertions:
    - result.code ShouldEqual 0

- name: encode_JWT_with_ES384
  steps:
  - type: exec
    script: |
      cd ..
      go run . encode es384 --pk tests/ES384-private.pem --p '{ "email": "{{.EMAIL}}" }' 
    assertions:
    - result.code ShouldEqual 0
    vars:
      token:
        from: result.systemout
        # regex: foo with a ([a-z]+) here

- name: decode JWT with ES384 with private key
  steps:
  - type: exec
    script: |
      cd ..
      go run . decode es384 --pk tests/ES384-private.pem --t '{{.encode_JWT_with_ES384.token}}'
    # info: go run . decode es384 --pk tests/ES384-private.pem --t '{{.encode_JWT_with_ES384.token}}'
    assertions:
    - result.code ShouldEqual 0

- name: decode JWT with ES384 with public key
  steps:
  - type: exec
    script: |
      cd ..
      go run . decode es384 --pubk tests/ES384-public.pem --t '{{.encode_JWT_with_ES384.token}}'
    # info: go run . decode es384 --pubk tests/ES384-public.pem --t '{{.encode_JWT_with_ES384.token}}'
    assertions:
    - result.code ShouldEqual 0

- name: encode_JWT_with_ES512
  steps:
  - type: exec
    script: |
      cd ..
      go run . encode es512 --pk tests/ES512-private.pem --p '{ "email": "{{.EMAIL}}" }' 
    assertions:
    - result.code ShouldEqual 0
    vars:
      token:
        from: result.systemout
        # regex: foo with a ([a-z]+) here

- name: decode JWT with ES512 with private key
  steps:
  - type: exec
    script: |
      cd ..
      go run . decode es512 --pk tests/ES512-private.pem --t '{{.encode_JWT_with_ES512.token}}'
    # info: go run . decode es256 --pk tests/ES512-private.pem --t '{{.encode_JWT_with_ES512.token}}'
    assertions:
    - result.code ShouldEqual 0

- name: decode JWT with ES512 with public key
  steps:
  - type: exec
    script: |
      cd ..
      go run . decode es512 --pubk tests/ES512-public.pem --t '{{.encode_JWT_with_ES512.token}}'
    # info: go run . decode es512 --pubk tests/ES512-public.pem --t '{{.encode_JWT_with_ES512.token}}'
    assertions:
    - result.code ShouldEqual 0

- name: encode_JWT_with_HS256
  steps:
  - type: exec
    script: |
      cd ..
      go run . encode hs256 --s "this-is-a-valid-32-byte-secret!!" --p '{ "email": "{{.EMAIL}}" }'
    assertions:
    - result.code ShouldEqual 0
    vars:
      token:
        from: result.systemout
        # regex: foo with a ([a-z]+) here

- name: decode JWT with HS256
  steps:
  - type: exec
    script: |
      cd ..
      go run . decode hs256 --s "this-is-a-valid-32-byte-secret!!"  --t '{{.encode_JWT_with_HS256.token}}'
    # info: go run . decode hs256 --s "this-is-a-valid-32-byte-secret!!" --t '{{.encode_JWT_with_HS256.token}}'
    assertions:
    - result.code ShouldEqual 0


- name: encode_JWT_with_HS384
  steps:
  - type: exec
    script: |
      cd ..
      go run . encode hs384 --s "this-is-a-valid-48-byte-secret-for-hs384-algo!!!" --p '{ "email": "{{.EMAIL}}" }'
    assertions:
    - result.code ShouldEqual 0
    vars:
      token:
        from: result.systemout
        # regex: foo with a ([a-z]+) here

- name: decode JWT with HS384
  steps:
  - type: exec
    script: |
      cd ..
      go run . decode hs384 --s "this-is-a-valid-48-byte-secret-for-hs384-algo!!!"  --t '{{.encode_JWT_with_HS384.token}}'
    # info: go run . decode hs384 --s "this-is-a-valid-48-byte-secret-for-hs384-algo!!!" --t '{{.encode_JWT_with_HS384.token}}'
    assertions:
    - result.code ShouldEqual 0


- name: encode_JWT_with_HS512
  steps:
  - type: exec
    script: |
      cd ..
      go run . encode hs512 --s "this-is-a-valid-64-byte-secret-for-hs512-algorithm-very-long!!!!" --p '{ "email": "{{.EMAIL}}" }'
    assertions:
    - result.code ShouldEqual 0
    vars:
      token:
        from: result.systemout
        # regex: foo with a ([a-z]+) here

- name: decode JWT with HS512
  steps:
  - type: exec
    script: |
      cd ..
      go run . decode hs512 --s "this-is-a-valid-64-byte-secret-for-hs512-algorithm-very-long!!!!"  --t '{{.encode_JWT_with_HS512.token}}'
    # info: go run . decode hs512 --s "this-is-a-valid-64-byte-secret-for-hs512-algorithm-very-long!!!!" --t '{{.encode_JWT_with_HS512.token}}'
    assertions:
    - result.code ShouldEqual 0

